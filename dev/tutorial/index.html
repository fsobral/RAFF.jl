<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · RAFF- Robust Algebraic Fitting Function</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="RAFF- Robust Algebraic Fitting Function logo"/></a><h1>RAFF- Robust Algebraic Fitting Function</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li class="current"><a class="toctext" href>Tutorial</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Basic-usage-1">Basic usage</a></li><li><a class="toctext" href="#Multivariate-models-1">Multivariate models</a></li><li><a class="toctext" href="#Changing-some-options-1">Changing some options</a></li><li><a class="toctext" href="#Parallel-running-1">Parallel running</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../api/">API</a></li><li><a class="toctext" href="../advanced/">Advanced</a></li><li><a class="toctext" href="../randomgeneration/">Random generation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Tutorial</a></li></ul><a class="edit-page" href="https://github.com/fsobral/RAFF.jl/blob/master/docs/src/tutorial.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Tutorial</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><div></div><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>This package is supported just for Julia version 1.0. Consequently,  it uses package 3.0. Currently <code>RAFF</code> is registered in <a href="https://github.com/JuliaRegistries">General Julia Registers</a>, so the  package can be installed using the Julia package manager. From the Julia REPL, type <code>]</code> to enter into Pkg REPL mode and run:</p><pre><code class="language-none">pkg&gt; add RAFF</code></pre><p>In what follows, we provide some simple examples on how to solve problems with <code>RAFF</code>. All the examples, and some other ones, are given in the <code>examples/</code> directory as Julia scripts.</p><h2><a class="nav-anchor" id="Basic-usage-1" href="#Basic-usage-1">Basic usage</a></h2><p>Just to illustrate the potential and basic usage of <code>RAFF</code>, let us consider the following data set given by an array <span>$A$</span>:</p><div>\[A=\left[ \begin{array}{cc}
 -2.0 &amp;  5.0 \\
 -1.5 &amp;  3.25\\
 -1.0 &amp;  2.0 \\
 -0.5 &amp;  1.25\\
  0.0 &amp;  1.0 \\
  0.5 &amp;  1.25\\
  1.0 &amp;  2.0 \\
  1.5 &amp;  3.25\\
  2.0 &amp;  5.0 \\
\end{array}\right]\]</div><p>Let&#39;s suppose the first column of <span>$A$</span> as an experimental measure with  result given by second column. It is easy to see that the fitting  function in this case is accurate and given by </p><div>\[\phi(x) = x^2 + 1\]</div><p>Now let&#39;s perturb one result of second column of <span>$A$</span>. For example,  consider <span>$A_{6,2} = 2.55$</span>. Assuming the model for fitting given by</p><div>\[\varphi(x; \theta) = \theta_1 x^2 + \theta_2 \]</div><p>we have by classical least squares as result <code>θ = [0.904329, 1.3039]</code>. On the other hand, when we consider <code>RAFF</code> algorithm we obtain the correct answer <code>θ = [1.0, 1.0]</code>. Moreover, we also have a list of the possible outliers.</p><p>In order to run <code>RAFF</code> algorithm we need to setup </p><pre><code class="language-julia-repl">julia&gt; using RAFF</code></pre><p>and define the data set and model:</p><pre><code class="language-julia-repl">julia&gt; A=[-2.0  5.0;
          -1.5  3.25;
          -1.0  2.0 ;
          -0.5  1.25;
           0.0  1.0 ;
           0.5  2.55;
           1.0  2.0 ;
           1.5  3.25;
           2.0  5.0 ;];

julia&gt; model(x, θ) = θ[1] * x[1]^2 + θ[2]
model (generic function with 1 method)</code></pre><p>After that, we can run method <a href="../api/#RAFF.raff"><code>raff</code></a>:</p><pre><code class="language-julia-repl">julia&gt; raff(model, A, 2)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [0.999998774479423, 1.000003442880683]
Number of iterations (.iter) = 39
Number of trust points (.p) = 8
Objective function value (.f) = 3.672268261041584e-11
Number of function evaluations (.nf) = 39
Number of Jacobian evaluations (.nj) = 39
Index of outliers (.outliers) = [6]</code></pre><p>The number <code>2</code> above is the number of variables in model, i. e., the number of parameters to adjust in the model. The output is a <a href="../api/#RAFF.RAFFOutput"><code>RAFFOutput</code></a> type. For example, to access only the parameters of solution, we can use</p><pre><code class="language-julia-repl">julia&gt; output = raff(model, A, 2)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [0.999998774479423, 1.000003442880683]
Number of iterations (.iter) = 39
Number of trust points (.p) = 8
Objective function value (.f) = 3.672268261041584e-11
Number of function evaluations (.nf) = 39
Number of Jacobian evaluations (.nj) = 39
Index of outliers (.outliers) = [6]

julia&gt; output.solution
2-element Array{Float64,1}:
 0.999998774479423
 1.000003442880683</code></pre><p>Note that <code>RAFF</code> algorithm detects and ignores possible outliers. In order to see which points are outliers, we can access the <code>outliers</code> attribute.</p><pre><code class="language-julia-repl">julia&gt; output.outliers
1-element Array{Int64,1}:
 6</code></pre><p>More details about <code>RAFFOutput</code> type and other options can be obtained in <a href="../api/">API section</a>.</p><p>By default <code>RAFF</code> uses automatic differentiation, more specifically <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl package</a>. But is possible to call <code>RAFF</code> methods with gradient vector of model. For example, considering the above example, we have,</p><div>\[\nabla \varphi(x; \theta) = [x^2, 1].\]</div><p>Programming this gradient and running <code>RAFF</code> we have</p><pre><code class="language-julia-repl">julia&gt; gmodel!(g, x, θ) = begin
          g[1] = x[1]^2
          g[2] = 1.0
       end
gmodel! (generic function with 1 method)

julia&gt; raff(model, gmodel!, A, 2)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [0.999998774479423, 1.000003442880683]
Number of iterations (.iter) = 39
Number of trust points (.p) = 8
Objective function value (.f) = 3.672268261041584e-11
Number of function evaluations (.nf) = 39
Number of Jacobian evaluations (.nj) = 39
Index of outliers (.outliers) = [6]</code></pre><p>Preliminary tests have shown that the use of explicit derivatives is 10 times faster than automatic differentiation.</p><h2><a class="nav-anchor" id="Multivariate-models-1" href="#Multivariate-models-1">Multivariate models</a></h2><p><code>RAFF</code> supports the use of multivariate fitting functions to data sets of different dimensions. To illustrate how this works, consider the following example:</p><pre><code class="language-julia-repl">julia&gt; data = [1.0 1.0    2.0
               0.0 0.0    4.0
               7.0 1.5   -4.5
               2.0 2.0  -17.0 # outlier
               0.0 8.6   -4.6]
5×3 Array{Float64,2}:
 1.0  1.0    2.0
 0.0  0.0    4.0
 7.0  1.5   -4.5
 2.0  2.0  -17.0
 0.0  8.6   -4.6</code></pre><p>and the following model</p><pre><code class="language-julia-repl">julia&gt; model(x, θ) = θ[1] * x[1] + θ[2] * x[2] + θ[3]
model (generic function with 1 method)</code></pre><p>Note that this model has two variables <span>$(x_1, x_2)$</span> and three parameters <span>$(\theta_1, \theta_2, \theta_3)$</span>. This problem has one outlier (<code>data[4,:]</code>), so there are 4 trusted points. Let&#39;s run <code>RAFF</code> and check the answer.</p><pre><code class="language-julia-repl">julia&gt; output = raff(model, data, 3)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [-0.9999994158240709, -0.9999994546240264, 3.9999956758615816]
Number of iterations (.iter) = 28
Number of trust points (.p) = 4
Objective function value (.f) = 2.9377653725356374e-11
Number of function evaluations (.nf) = 28
Number of Jacobian evaluations (.nj) = 28
Index of outliers (.outliers) = [4]</code></pre><p>The right answer is <code>[-1.0, -1.0, 4.0]</code>. As we can note, <code>RAFF</code> get a good fit for the data set. Handling the output follows the same pattern as the one-dimensional case.</p><p>In order to get improvements in processing time, we can code the gradient vector of model too:</p><pre><code class="language-julia-repl">julia&gt; gmodel!(g, x, θ) = begin
           g[1] = x[1]
           g[2] = x[2]
           g[3] = 1.0
       end
gmodel! (generic function with 1 method)</code></pre><pre><code class="language-julia-repl">julia&gt; output = raff(model, gmodel!, data, 3)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [-0.9999994158240709, -0.9999994546240264, 3.9999956758615816]
Number of iterations (.iter) = 28
Number of trust points (.p) = 4
Objective function value (.f) = 2.9377653725356374e-11
Number of function evaluations (.nf) = 28
Number of Jacobian evaluations (.nj) = 28
Index of outliers (.outliers) = [4]</code></pre><h2><a class="nav-anchor" id="Changing-some-options-1" href="#Changing-some-options-1">Changing some options</a></h2><p><code>RAFF</code> has tunning options like precision of gradient stopping criteria and initial guess.</p><pre><code class="language-julia-repl">julia&gt; output = raff(model, data, 3; initguess=[0.5,0.5,0.5], ε=1.0e-4)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [-0.9237801182083769, -0.7578132500754239, -0.18697627769713313]
Number of iterations (.iter) = 28
Number of trust points (.p) = 5
Objective function value (.f) = 228.6473817033248
Number of function evaluations (.nf) = 28
Number of Jacobian evaluations (.nj) = 28
Index of outliers (.outliers) = Int64[]</code></pre><p><code>RAFF</code> is based on an optimization method. In this way, it is subject to stopping at stationary points that are not global minimizers. For this reason, heuristics were implemented to find global minimizers. Such heuristics depend on random number generation. So, if you want to run tests with more reliability this can be a useful strategy. To define in <code>RAFF</code>, say, 1000 different starting points, is enough to redefine the keyword argument <code>MAXMS</code>.</p><pre><code class="language-julia-repl">julia&gt; output = raff(model, data, 3; MAXMS=1, initguess=[0.5,0.5,0.5], ε=1.0e-10)
** RAFFOutput **
Status (.status) = 1
Solution (.solution) = [-0.9999999999999273, -0.9999999999999324, 3.9999999999994627]
Number of iterations (.iter) = 41
Number of trust points (.p) = 4
Objective function value (.f) = 4.536928392543292e-25
Number of function evaluations (.nf) = 41
Number of Jacobian evaluations (.nj) = 41
Index of outliers (.outliers) = [4]</code></pre><p>In the above example, we have also changed the starting point for the method. Also, the stopping criterion was changed to <span>$10^{-10}$</span>, which means high accuracy when solving the subproblems. See <a href="../api/#RAFF"><code>RAFF</code> API</a> for all the possible options that can be used.</p><h2><a class="nav-anchor" id="Parallel-running-1" href="#Parallel-running-1">Parallel running</a></h2><p><code>RAFF</code> can be run in a parallel or distributed environment, using the <a href="https://docs.julialang.org/en/v1.0/stdlib/Distributed/">Distributed</a> package and function <a href="../api/#RAFF.praff"><code>praff</code></a>. Let&#39;s use <code>praff</code> to solve the same problem from the beginning. First, the Distributed package has to be loaded and the number of workers has to be added. It is also possible to add the address of other machines.</p><pre><code class="language-none">using Distributed

addprocs(3) # Add 3 worker processes</code></pre><p>This step can be replaced if Julia is initialized with the <code>-p</code> option</p><pre><code class="language-none">julia -p 3</code></pre><p>Now we have to load <a href="../#Overview-1"><code>RAFF</code></a> and the fit function in all workers:</p><pre><code class="language-none">@everywhere using RAFF

@everywhere function model(x, θ)
   θ[1] * x[1]^2 + θ[2]
end

@everywhere function gmodel!(g, x, θ)
    g[1] = x[1]^2
    g[2] = 1.0
end</code></pre><p>then, we call <a href="../api/#RAFF.praff"><code>praff</code></a> to solve the problem (note that we do not need to send the <code>A</code> matrix to all workers, since it will be automatically sent by <code>praff</code>).</p><pre><code class="language-none">A=[-2.0  5.0;
  -1.5  3.25;
  -1.0  2.0 ;
  -0.5  1.25;
   0.0  1.0 ;
   0.5  2.55;
   1.0  2.0 ;
   1.5  3.25;
   2.0  5.0 ;];

n = 2

output = praff(model, gmodel!, A, n)
RAFFOutput(1, [1.0, 0.999996], 6, 8, 4.0205772365906425e-11, [6])</code></pre><p>The true effectiveness of parallelism occurs when option <code>MAXMS</code> is set, which changes the number of random initial points that are tried for each subproblem solved. Better solutions can be achieved with higher values of <code>MAXMS</code></p><pre><code class="language-none">n = 2

output = praff(model, gmodel!, A, n; MAXMS=1000)
RAFFOutput(1, [1.0, 1.0], 7, 8, 5.134133698545651e-13, [6])</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Overview</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
