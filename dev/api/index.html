<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · RAFF- Robust Algebraic Fitting Function</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="RAFF- Robust Algebraic Fitting Function logo"/></a><h1>RAFF- Robust Algebraic Fitting Function</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li><a class="toctext" href="../tutorial/">Tutorial</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"><li><a class="toctext" href="#Summary-1">Summary</a></li><li><a class="toctext" href="#Main-functions-1">Main functions</a></li><li><a class="toctext" href="#Auxiliary-functions-1">Auxiliary functions</a></li><li><a class="toctext" href="#Random-generation-1">Random generation</a></li><li><a class="toctext" href="#Output-type-1">Output type</a></li></ul></li><li><a class="toctext" href="../advanced/">Advanced</a></li><li><a class="toctext" href="../randomgeneration/">Random generation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/fsobral/RAFF.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Summary-1" href="#Summary-1">Summary</a></h2><p>There are four main RAFF structures: </p><ol><li><em><a href="#Main-functions-1">Main functions</a>:</em> directly called by user; </li><li><em><a href="#Auxiliary-functions-1">Auxiliary functions</a>:</em> used like internal auxiliary functions;</li><li><em><a href="#Random-generation-1">Random generation</a>:</em> used to generate random sets of data, in order to test <code>RAFF</code></li><li><em><a href="#Output-type-1">Output type</a>:</em> type defined to manipulate output information.</li></ol><h2><a class="nav-anchor" id="Main-functions-1" href="#Main-functions-1">Main functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.lmlovo" href="#RAFF.lmlovo"><code>RAFF.lmlovo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lmlovo(model::Function [, θ::Vector{Float64} = zeros(n)], data::Array{Float64, 2},
       n::Int, p::Int [; kwargs...])

lmlovo(model::Function, gmodel!::Function [, θ::Vector{Float64} = zeros(n)],
       data::Array{Float64,2}, n::Int, p::Int [; MAXITER::Int=200,
       ε::Float64=10.0^-4])</code></pre><p>Fit the <code>n</code>-parameter model <code>model</code> to the data given by matrix <code>data</code>. The strategy is based on the LOVO function, which means that only <code>p</code> (0 &lt; <code>p</code> &lt;= rows of <code>data</code>) points are trusted. The Levenberg-Marquardt algorithm is implemented in this version.</p><p>Matriz <code>data</code> is the data to be fit. This matrix should be in the form</p><pre><code class="language-none">x11 x12 ... x1N y1
x21 x22 ... x2N y2
:</code></pre><p>where <code>N</code> is the dimension of the argument of the model (i.e. dimension of <code>x</code>).</p><p>If <code>θ</code> is provided, then it is used as the starting point.</p><p>The signature of function <code>model</code> should be given by</p><pre><code class="language-none">model(x::Union{Vector{Float64}, SubArray}, θ::Vector{Float64})</code></pre><p>where <code>x</code> are the variables and <code>θ</code> is a <code>n</code>-dimensional vector of parameters. If the gradient of the model <code>gmodel!</code></p><pre><code class="language-none">gmodel! = (g::SubArray, x::Union{Vector{Float64}, SubArray},
           θ::Vector{Float64})</code></pre><p>is not provided, then the function ForwardDiff.gradient! is called to compute it.  <strong>Note</strong> that this choice has an impact in the computational performance of the algorithm. In addition, if <code>ForwardDiff.jl</code> is being used, then one <strong>MUST</strong> remove the signature of vector <code>θ</code> from function <code>model</code>.</p><p>The optional arguments are</p><ul><li><code>MAXITER</code>: maximum number of iterations</li><li><code>ε</code>: tolerance for the gradient of the function</li></ul><p>Returns a <a href="#RAFF.RAFFOutput"><code>RAFFOutput</code></a> object.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/RAFF.jl#L37-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.raff" href="#RAFF.raff"><code>RAFF.raff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">raff(model::Function, data::Array{Float64, 2}, n::Int; kwargs...)

raff(model::Function, gmodel!::Function, data::Array{Float64, 2},
    n::Int; MAXMS::Int=1, SEEDMS::Int=123456789,
    initguess::Vector{Float64}=zeros(Float64, n),
    ε::Float64=1.0e-4, noutliers::Int=-1, ftrusted::Union{Float64,
    Tuple{Float64, Float64}}=0.5)</code></pre><p>Robust Algebric Fitting Function (RAFF) algorithm. This function uses a voting system to automatically find the number of trusted data points to fit the <code>model</code>.</p><ul><li><p><code>model</code>: function to fit data. Its signature should be given by</p><pre><code class="language-none">model(x, θ)</code></pre><p>where <code>x</code> is the multidimensional argument and <code>θ</code> is the <code>n</code>-dimensional vector of parameters</p></li><li><p><code>gmodel!</code>: gradient of the model function. Its signature should be given by</p><pre><code class="language-none">gmodel!(g, x, θ)</code></pre><p>where <code>x</code> is the multidimensional argument, <code>θ</code> is the <code>n</code>-dimensional vector of parameters and the gradient is written in <code>g</code>.</p></li><li><p><code>data</code>: data to be fit. This matrix should be in the form</p><pre><code class="language-none">x11 x12 ... x1N y1
x21 x22 ... x2N y2
:</code></pre><p>where <code>N</code> is the dimension of the argument of the model (i.e. dimension of <code>x</code>).</p></li><li><p><code>n</code>: dimension of the parameter vector in the model function</p></li></ul><p>The optional arguments are</p><ul><li><code>MAXMS</code>: number of multistart points to be used</li><li><code>SEEDMS</code>: integer seed for random multistart points</li><li><code>initialguess</code>: a good guess for the starting point and for generating random points in the multistart strategy</li><li><code>ε</code>: gradient stopping criteria to <code>lmlovo</code></li><li><code>noutliers</code>: integer describing the maximum expected number of outliers. The default is <em>half</em>. <em>Deprecated</em>.</li><li><code>ftrusted</code>: float describing the minimum expected percentage of trusted points. The default is <em>half</em> (0.5). Can also be a Tuple of the form <code>(fmin, fmax)</code> percentages of trusted points.</li></ul><p>Returns a <a href="#RAFF.RAFFOutput"><code>RAFFOutput</code></a> object with the best parameter found.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/RAFF.jl#L343-L399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.praff" href="#RAFF.praff"><code>RAFF.praff</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">praff(model::Function, data::Array{Float64, 2}, n::Int; kwargs...)

praff(model::Function, gmodel!::Function, data::Array{Float64, 2},
    n::Int; MAXMS::Int=1, SEEDMS::Int=123456789, batches::Int=1,
    initguess::Vector{Float64}=zeros(Float64, n),
    ε::Float64=1.0e-4, noutliers::Int=-1, ftrusted::Union{Float64,
    Tuple{Float64, Float64}}=0.5)</code></pre><p>Multicore distributed version of RAFF. See the description of the <a href="#RAFF.raff"><code>raff</code></a> function for the main (non-optional) arguments. All the communication is performed by channels.</p><p>This function uses all available <strong>local</strong> workers to run RAFF algorithm. Note that this function does not use <em>Tasks</em>, so all the parallelism is based on the <a href="https://docs.julialang.org/en/latest/manual/parallel-computing/#Multi-Core-or-Distributed-Processing-1">Distributed</a> package.</p><p>The optional arguments are</p><ul><li><code>MAXMS</code>: number of multistart points to be used</li><li><code>SEEDMS</code>: integer seed for random multistart points</li><li><code>batches</code>: size of batches to be send to each worker</li><li><code>initguess</code>: starting point to be used in the multistart procedure</li><li><code>ε</code>: stopping tolerance</li><li><code>noutliers</code>: integer describing the maximum expected number of outliers. The default is <em>half</em>. <em>Deprecated</em>.</li><li><code>ftrusted</code>: float describing the minimum expected percentage of trusted points. The default is <em>half</em> (0.5). Can also be a Tuple of the form <code>(fmin, fmax)</code> percentages of trusted points.</li></ul><p>Returns a <a href="#RAFF.RAFFOutput"><code>RAFFOutput</code></a> object containing the solution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/RAFF.jl#L529-L562">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.set_raff_output_level" href="#RAFF.set_raff_output_level"><code>RAFF.set_raff_output_level</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_raff_output_level(level::LogLevel)</code></pre><p>Set the output level of <a href="#RAFF.raff"><code>raff</code></a> and <a href="#RAFF.praff"><code>praff</code></a> algorithms to the desired logging level. Options are (from highly verbose to just errors): <code>Logging.Debug</code>, <code>Logging.Info</code>, <code>Logging.Warn</code> and <code>Logging.Error</code>. The package <a href="https://docs.julialang.org/en/v1.0/stdlib/Logging/index.html"><code>Logging</code></a> needs to be loaded.</p><p>Defaults to <code>Logging.Error</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/utils.jl#L268-L281">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.set_lm_output_level" href="#RAFF.set_lm_output_level"><code>RAFF.set_lm_output_level</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_lm_output_level(level::LogLevel)</code></pre><p>Set the output level of <a href="#RAFF.lmlovo"><code>lmlovo</code></a> algorithm to the desired logging level. Options are (from highly verbose to just errors): <code>Logging.Debug</code>, <code>Logging.Info</code>, <code>Logging.Warn</code> and <code>Logging.Error</code>. The package <a href="https://docs.julialang.org/en/v1.0/stdlib/Logging/index.html"><code>Logging</code></a> needs to be loaded.</p><p>Defaults to <code>Logging.Error</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/utils.jl#L288-L301">source</a></section><h2><a class="nav-anchor" id="Auxiliary-functions-1" href="#Auxiliary-functions-1">Auxiliary functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.voting_strategy" href="#RAFF.voting_strategy"><code>RAFF.voting_strategy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">voting_strategy(model::Function, data::Array{Float64, 2}, sols::Vector{RAFFOutput}, pliminf::Int,
                plimsup::Int)</code></pre><p>Utility function to compute the matrix representing the voting system used by RAFF.</p><p>It first applies a filtering strategy, to eliminate obvious local minima, then it calculates a <em>magic threshold</em> and constructs the distance matrix. The vector <code>sols</code> contains the solutions <code>s_p</code>, for <code>p = pliminf, ... plimsup</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/utils.jl#L3-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.eliminate_local_min!" href="#RAFF.eliminate_local_min!"><code>RAFF.eliminate_local_min!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eliminate_local_min!(sols::Vector{RAFFOutput})</code></pre><p>Check if the function value of the solution found by smaller values of <code>p</code> is not greater when compared with larger ones. This certainly indicates that a local minimizer was found by the smaller <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/utils.jl#L122-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.sort_fun!" href="#RAFF.sort_fun!"><code>RAFF.sort_fun!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>This function is an auxiliary function. It finds the <code>p</code> smallest values of vector <code>V</code> and brings them to the first <code>p</code> positions. The indexes associated with the <code>p</code> smallest values are stored in <code>ind</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/utils.jl#L229-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.update_best" href="#RAFF.update_best"><code>RAFF.update_best</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">update_best(channel::RemoteChannel, bestx::SharedArray{Float64, 1})</code></pre><p>Listen to a <code>channel</code> for results found by lmlovo. If there is an improvement for the objective function, the shared array <code>bestx</code> is updated.</p><p><strong>Attention</strong>: There might be an unstable state if there is a process   reading <code>bestx</code> while this function is updating it. This should not   be a problem, since it is used as a starting point.</p><p><strong>Attention 2</strong>: this function is currently out of use.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/dutils.jl#L4-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.consume_tqueue" href="#RAFF.consume_tqueue"><code>RAFF.consume_tqueue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function consume_tqueue(bqueue::RemoteChannel, tqueue::RemoteChannel,
                        squeue::RemoteChannel, model::Function, gmodel!::Function,
                        data::Array{Float64, 2}, n::Int, pliminf::Int,
                        plimsup::Int, MAXMS::Int, seedMS::MersenneTwister)</code></pre><p>This function represents one worker, which runs lmlovo in a multistart fashion.</p><p>It takes a job from the RemoteChannel <code>tqueue</code> and runs <code>lmlovo</code> function to it. It might run using a multistart strategy, if <code>MAXMS&gt;1</code>. It sends the best results found for each value obtained in <code>tqueue</code> to channel <code>squeue</code>, which will be consumed by the main process. All the other arguments are the same for <a href="#RAFF.praff"><code>praff</code></a> function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/dutils.jl#L60-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.check_and_close" href="#RAFF.check_and_close"><code>RAFF.check_and_close</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_and_close(bqueue::RemoteChannel, tqueue::RemoteChannel,
                squeue::RemoteChannel, futures::Vector{Future};
                secs::Float64=0.1)</code></pre><p>Check if there is at least one worker process in the vector of <code>futures</code> that has not prematurely finished. If there is no alive worker, close task, solution and best queues, <code>tqueue</code>, <code>squeue</code> and <code>bqueue</code>, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/dutils.jl#L197-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.check_ftrusted" href="#RAFF.check_ftrusted"><code>RAFF.check_ftrusted</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">check_ftrusted(ftrusted::Union{Float64, Tuple{Float64, Float64}}, np::Int)</code></pre><p>Utility function to check <code>ftrusted</code> parameter in <a href="#RAFF.raff"><code>raff</code></a> and <a href="#RAFF.praff"><code>praff</code></a>. Throws an <code>ErrorException</code> if the percentage of trusted points is incorrect.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/utils.jl#L96-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.interval_rand!" href="#RAFF.interval_rand!"><code>RAFF.interval_rand!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">interval_rand!(x::Vector{Float64},
    intervals::Vector{Tuple{Float64, Float64}})</code></pre><p>Fill a vector <code>x</code> with uniformly distributed random numbers generated in the interval given by <code>intervals</code>. It is assumed that <code>length(x) == length(intervals)</code>.</p><p>Throws an <code>ErrorException</code> if the dimension of <code>x</code> is smaller the dimension of <code>intervals</code> or if the intervals are invalid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L33-L45">source</a></section><h2><a class="nav-anchor" id="Random-generation-1" href="#Random-generation-1">Random generation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_test_problems" href="#RAFF.generate_test_problems"><code>RAFF.generate_test_problems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_test_problems(datFilename::String, solFilename::String,
    model::Function, modelStr::String, n::Int, np::Int, p::Int;
    x_interval::Tuple{Float64, Float64}=(-10.0, 10.0),
    θSol::Vector{Float64}=10.0 * randn(n), std::Float64=200.0,
    out_times::Float64=7.0)

generate_test_problems(datFilename::String, solFilename::String,
    model::Function, modelStr::String, n::Int, np::Int, p::Int,
    cluster_interval::Tuple{Float64, Float64};
    x_interval::Tuple{Float64, Float64}=(-10.0, 10.0),
    θSol::Vector{Float64}=10.0 * randn(n), std::Float64=200.0,
    out_times::Float64=7.0)</code></pre><p>Generate random data files for testing fitting problems.</p><ul><li><p><code>datFilename</code> and <code>solFilename</code> are strings with the name of the files for storing the random data and solution, respectively.</p></li><li><p><code>model</code> is the model function and <code>modelStr</code> is a string representing this model function, e.g.</p><pre><code class="language-none"> model = (x, θ) -&gt; θ[1] * x[1] + θ[2]
 modelStr = &quot;(x, θ) -&gt; θ[1] * x[1] + θ[2]&quot;</code></pre><p>where vector <code>θ</code> represents the parameters (to be found) of the model and vector <code>x</code> are the variables of the model.</p></li><li><p><code>n</code> is the number of parameters</p></li><li><p><code>np</code> is the number of points to be generated.</p></li><li><p><code>p</code> is the number of trusted points to be used in the LOVO approach.</p></li></ul><p>If <code>cluster_interval</code> is provided, then generates outliers only in this interval.</p><p>Additional parameters:</p><ul><li><code>xMin</code>, <code>xMax</code>: interval for generating points in one dimensional tests <em>Deprecated</em></li><li><code>x_interval</code>: interval for generating points in one dimensional tests</li><li><code>θSol</code>: true solution, used for generating perturbed points</li><li><code>std</code>: standard deviation</li><li><code>out_times</code>: deviation for outliers will be <code>out_times * std</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L62-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.get_unique_random_points" href="#RAFF.get_unique_random_points"><code>RAFF.get_unique_random_points</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_unique_random_points(np::Int, npp::Int)</code></pre><p>Choose exactly <code>npp</code> unique random points from a set containing <code>np</code> points. This function is similar to <code>rand(vector)</code>, but does not allow repetitions.</p><p>If <code>npp</code> &lt; <code>np</code>, returns all the <code>np</code> points. Note that this function is not very memory efficient, since the process of selecting unique elements involves creating several temporary vectors.</p><p>Return a vector with the selected points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L347-L361">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.get_unique_random_points!" href="#RAFF.get_unique_random_points!"><code>RAFF.get_unique_random_points!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_unique_random_points!(v::Vector{Int}, np::Int, npp::Int)</code></pre><p>Choose exactly <code>npp</code> unique random points from a set containing <code>np</code> points. This function is similar to <code>rand(vector)</code>, but does not allow repetitions.</p><p>If <code>npp</code> &lt; <code>np</code>, returns all the <code>np</code> points. Note that this function is not very memory efficient, since the process of selecting unique elements involves creating several temporary vectors.</p><p>Return the vector <code>v</code> provided as argument filled with the selected points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L375-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_noisy_data!" href="#RAFF.generate_noisy_data!"><code>RAFF.generate_noisy_data!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_noisy_data!(data::AbstractArray{Float64, 2},
    v::Vector{Int}, model::Function, n::Int, np::Int, p::Int;
    x_interval::Tuple{Float64, Float64}=(-10.0, 10.0),
    θSol::Vector{Float64}=10.0 * randn(Float64, n),
    std::Float64=200.0, out_times::Float64=7.0)</code></pre><p>Random generate a fitting one-dimensional data problem, storing the data in matrix <code>data</code> and the outliers in vector <code>v</code>.</p><p>This function receives a <code>model(x, θ)</code> function, the number of parameters <code>n</code>, the number of points <code>np</code> to be generated and the number of trusted points <code>p</code>. </p><p>If the <code>n</code>-dimensional vector <code>θSol</code> is provided, then the exact solution will not be random generated. The interval <code>[xMin, xMax]</code> (<em>deprecated</em>) or <code>x_interval</code> for generating the values to evaluate <code>model</code> can also be provided.</p><p>It returns a tuple <code>(data, θSol, outliers)</code> where</p><ul><li><code>data</code>: (<code>np</code> x <code>3</code>) array, where each row contains <code>x</code> and <code>model(x, θSol)</code>.</li><li><code>θSol</code>: <code>n</code>-dimensional vector with the exact solution.</li><li><code>outliers</code>: the outliers of this data set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L499-L526">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_noisy_data" href="#RAFF.generate_noisy_data"><code>RAFF.generate_noisy_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_noisy_data(model::Function, n::Int, np::Int, p::Int;
    x_interval::Tuple{Float64, Float64}=(-10.0, 10.0),
    θSol::Vector{Float64}=10.0 * randn(Float64, n),
    std::Float64=200.0, out_times::Float64=7.0)

generate_noisy_data(model::Function, n::Int, np::Int, p::Int,
    x_interval::Tuple{Float64, Float64})

generate_noisy_data(model::Function, n::Int, np::Int, p::Int,
    θSol::Vector{Float64}, x_interval::Tuple{Float64, Float64})</code></pre><p>Random generate a fitting one-dimensional data problem.</p><p>This function receives a <code>model(x, θ)</code> function, the number of parameters <code>n</code>, the number of points <code>np</code> to be generated and the number of trusted points <code>p</code>. </p><p>If the <code>n</code>-dimensional vector <code>θSol</code> is provided, then the exact solution will not be random generated. The interval <code>[xMin, xMax]</code> (<em>deprecated</em>) or <code>x_interval</code> for generating the values to evaluate <code>model</code> can also be provided.</p><p>It returns a tuple <code>(data, θSol, outliers)</code> where</p><ul><li><code>data</code>: (<code>np</code> x <code>3</code>) array, where each row contains <code>x</code> and <code>model(x, θSol)</code>.</li><li><code>θSol</code>: <code>n</code>-dimensional vector with the exact solution.</li><li><code>outliers</code>: the outliers of this data set</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L433-L465">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_clustered_noisy_data!" href="#RAFF.generate_clustered_noisy_data!"><code>RAFF.generate_clustered_noisy_data!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_clustered_noisy_data!(data::Array{Float64, 2},
    v::Vector{Int}, model::Function, n::Int, np::Int, p::Int,
    x_interval::Tuple{Float64,Float64},
    cluster_interval::Tuple{Float64, Float64}; kwargs...)</code></pre><p>Generate a test set with clustered outliers. This version overwrites the content of (<code>np</code> x <code>3</code>) matrix <code>data</code> and vector <code>v</code> with integer indices to the position of outliers in <code>data</code>.</p><p>The arguments and optional arguments are the same for <a href="#RAFF.generate_noisy_data!"><code>generate_noisy_data!</code></a>, with exception of tuple <code>cluster_interval</code> which is the interval to generate the clustered outliers.</p><p>It returns a tuple <code>(data, θSol, outliers)</code> where</p><ul><li><code>data</code>: (<code>np</code> x <code>3</code>) array, where each row contains <code>x</code> and <code>model(x, θSol)</code>. The same array given as argument</li><li><code>θSol</code>: <code>n</code>-dimensional vector with the exact solution.</li><li><code>outliers</code>: the outliers of this data set. The same vector given as argument.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L617-L641">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_clustered_noisy_data" href="#RAFF.generate_clustered_noisy_data"><code>RAFF.generate_clustered_noisy_data</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_clustered_noisy_data(model::Function, n::Int, np::Int,
    p::Int, x_interval::Tuple{Float64,Float64},
    cluster_interval::Tuple{Float64, Float64}; kwargs...)

generate_clustered_noisy_data(model::Function, n::Int,
    np::Int, p::Int, θSol::Vector{Float64},
    x_interval::Tuple{Float64,Float64},
    cluster_interval::Tuple{Float64, Float64}; kwargs...)</code></pre><p>Generate a test set with clustered outliers.</p><p>The arguments and optional arguments are the same for <a href="#RAFF.generate_noisy_data!"><code>generate_noisy_data!</code></a>, with exception of tuple <code>cluster_interval</code> which is the interval to generate the clustered outliers.</p><p>It returns a tuple <code>(data, θSol, outliers)</code> where</p><ul><li><code>data</code>: (<code>np</code> x <code>3</code>) array, where each row contains <code>x</code> and <code>model(x, θSol)</code>. The same array given as argument</li><li><code>θSol</code>: <code>n</code>-dimensional vector with the exact solution.</li><li><code>outliers</code>: the outliers of this data set. The same vector given as argument.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L571-L597">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_circle" href="#RAFF.generate_circle"><code>RAFF.generate_circle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_circle(dat_filename::String, np::Int, p::Int;
    std::Float64=0.1, θSol::Vector{Float64}=1.0*randn(Float64, 3),
    outTimes::Float64=3.0, interval=(rand(i)*2.0*π for i = 1:np))</code></pre><p>Generate perturbed points in a circle given by <code>θSol</code> and save to <code>dat_filename</code> in RAFF format. Return the np x 4 matrix with data (the 4th column is 0 if the point is &quot;correct&quot;) and a <code>np - p</code> integer vector containing the points selected to be outliers.</p><ul><li><code>dat_filename</code> is a String with the name of the file to store generated data.</li><li><code>np</code> is the number of points to be generated.</li><li><code>p</code> is the number of <em>trusted points</em> to be used in the LOVO approach.</li></ul><p>Additional configuration parameters are</p><ul><li><code>std</code>: standard deviation.</li><li><code>θSol</code>: true solution, used for generating perturbed points.</li><li><code>out_times</code>: deviation for outliers will be <code>out_times * std</code>.</li><li><code>interval</code>: any iterable object containing <code>np</code> numbers between 0 and 2π.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L187-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.generate_ncircle" href="#RAFF.generate_ncircle"><code>RAFF.generate_ncircle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">generate_ncircle(dat_filename::String,np::Int, p::Int;
  std::Float64=0.1, θSol::Vector{Float64}=10.0*randn(Float64, 3),
  interval=(rand()*2.0*π for i = 1:np))</code></pre><p>Generate perturbed points and uniform noise in a square containing the circle given by <code>θSol</code> and save data to <code>dat_filename</code> in RAFF format. Return the np x 4 matrix with data (the 4th column is 0 if the point is &quot;correct&quot;) and a <code>np - p</code> integer vector containing the points selected to be outliers.</p><ul><li><code>dat_filename</code> is a String with the name of the file to store generated data.</li><li><code>np</code> is the number of points to be generated.</li><li><code>p</code> is the number of <em>trusted points</em> to be used in the LOVO approach.</li></ul><p>Additional configuration parameters are</p><ul><li><code>std</code>: standard deviation.</li><li><code>θSol</code>: true solution, used for generating perturbed points.</li><li><code>interval</code>: any iterable object containing <code>np</code> numbers between 0 and 2π.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L268-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.model_list" href="#RAFF.model_list"><code>RAFF.model_list</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>This dictionary represents the list of models used in the generation of random tests. Return the tuple <code>(n, model, model_str)</code>, where</p><ul><li><code>n</code> is the number of parameters of the model</li><li><code>model</code> is the model of the form <code>m(x, θ)</code>, where <code>x</code> are the variables and <code>θ</code> are the parameters</li><li><code>model_str</code> is the string representing the model, used to build random generated problems</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/generator.jl#L6-L16">source</a></section><h2><a class="nav-anchor" id="Output-type-1" href="#Output-type-1">Output type</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RAFF.RAFFOutput" href="#RAFF.RAFFOutput"><code>RAFF.RAFFOutput</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>This type defines the output file for the RAFF algorithm.</p><pre><code class="language-none">RAFFOutput(status::Int, solution::Vector{Float64}, iter::Int,
           p::Int, f::Float64, nf::Int, nj::Int, outliers::Vector{Int})</code></pre><p>where</p><ul><li><p><code>status</code>: is 1 if converged and 0 if not</p></li><li><p><code>solution</code>: vector with the parameters of the model</p></li><li><p><code>iter</code>: number of iterations up to convergence</p></li><li><p><code>p</code>: number of trusted points</p></li><li><p><code>f</code>: the residual value</p></li><li><p><code>nf</code>: number of function evaluations</p></li><li><p><code>nj</code>: number of Jacobian evaluations</p></li><li><p><code>outliers</code>: the possible outliers detected by the method, for the given <code>p</code></p><p>RAFFOutput()</p></li></ul><p>Creates a null version of output, equivalent to <code>RAFFOutput(0, [], -1, 0, Inf, -1, -1, [])</code></p><pre><code class="language-none">RAFFOuput(p::Int)
RAFFOuput(sol::Vector{Float64}, p::Int)</code></pre><p>Creates a null version of output for the given <code>p</code> and a null version with the given solution, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/fsobral/RAFF.jl/blob/1cb7438df6b04f4294013d3346d0f6e6505d1978/src/raffoutput.jl#L3-L32">source</a></section><footer><hr/><a class="previous" href="../examples/"><span class="direction">Previous</span><span class="title">Examples</span></a><a class="next" href="../advanced/"><span class="direction">Next</span><span class="title">Advanced</span></a></footer></article></body></html>
